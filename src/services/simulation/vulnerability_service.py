import logging
from typing import List, Dict

from src.gateway.v1.models.filters import VulnerabilityFilter
from src.gateway.v1.models.responses import Vulnerability, AffectedSoftware, AffectedSystem
from src.services.country_service import country_from_alpha2
from src.services.neo4j_service import Neo4JService
from src.services.postgres_service import PostgresService
from src.services.simulation.db_models import VulnerabilitySql
from src.settings import APP_SETTINGS

logger = logging.getLogger(__name__)


class VulnerabilityService:
    def __init__(self,
                 postgres_url: str = APP_SETTINGS.postgres_url,
                 postgres: PostgresService[VulnerabilitySql] | None = None,
                 neo4j: Neo4JService | None = None):
        self.postgres = postgres or PostgresService(url=postgres_url, model=VulnerabilitySql, pool_size=5)
        self.neo4j = neo4j or Neo4JService()

    def _build_filter_options(
            self,
            filter: VulnerabilityFilter,
    ) -> list:
        filters = []

        filters += filter.get_datetime_filters(VulnerabilitySql.published_at)
        filters += filter.get_score_filters(VulnerabilitySql.score)

        return filters

    def query_count(
            self,
            filter: VulnerabilityFilter,
    ) -> int:
        filters = self._build_filter_options(filter)

        with self.postgres.transaction():
            return self.postgres.query().filter(*filters).count()

    def query_single(self, cve: str) -> Vulnerability | None:
        with self.postgres.transaction():
            result = self.postgres.query().filter(VulnerabilitySql.cve == cve).first()

        return Vulnerability.model_validate(result.__dict__) if result else None

    def query(
            self,
            vulnerability_filter: VulnerabilityFilter,
            limit: int = 50,
            skip: int = 0,
    ) -> list[Vulnerability]:
        filters = self._build_filter_options(vulnerability_filter)
        with self.postgres.transaction():
            results = (
                self.postgres.query()
                .filter(*filters)
                .order_by(VulnerabilitySql.cve)
                .limit(limit)
                .offset(skip)
                .all()
            )

        return [Vulnerability.model_validate(r.__dict__) for r in results]

    def find_affected_systems(self, cve: str) -> List[AffectedSystem]:
        affected_systems: Dict[str, AffectedSystem] = {}
        try:
            # all system that have software installed with the cve
            software_ids = self.neo4j.find_infected_softwareInstallation_from_CVE(cve)
            for software_id in software_ids:
                software = self.neo4j.find_Node_By_Id(software_id)
                logger.debug(f"Software: {software}")
                # all systems that have the software installed
                connections = self.neo4j.fetch_connections_by_id_rev_and_source(software_id, "System")
                for connection in connections:
                    sysId = connection["connected_elementId"]
                    sys = connection["connected_node"]
                    if sysId not in affected_systems:
                        country_result = self.neo4j.get_system_countries(sysId)
                        logger.debug(f"Country result: {country_result}")
                        countries = [country_from_alpha2(cc) for cc in country_result if cc]
                        logger.debug(f"Countries: {countries}")
                        non_none_countries = [country for country in countries if country is not None]
                        logger.debug(f"Non-none countries: {non_none_countries}")

                        affected_systems[sysId] = AffectedSystem(
                            critical=bool(sys['critical']),
                            provider=self.neo4j.get_system_provider(sysId),
                            software=[AffectedSoftware(
                                elementId=software_id,
                                product=software.get("product", ""),
                                publisher=software.get("publisher", ""),
                                version=software.get("version", ""),
                            )],
                            location=non_none_countries,
                            # TODO: Network traversal
                            network="")
                    else:
                        affected_systems[sysId].software.append(AffectedSoftware(
                            elementId=software_id,
                            product=software.get("product", ""),
                            publisher=software.get("publisher", ""),
                            version=software.get("version", ""),
                        ))

            return list(affected_systems.values())
        except Exception as e:
            logger.error(f"Error finding affected systems for CVE {cve}: {e}")
            return list(affected_systems.values())
